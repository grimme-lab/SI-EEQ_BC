"""
Python script to plot the partial charge of an atom in a two-atom-molecule depending on the distance between the atoms.
"""

import argparse
from pathlib import Path

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns  # type: ignore
import pandas as pd

# Constants
CM_TO_INCH = 1 / 2.54
VERBOSITY = 1
PSE = {
    0: "X",
    1: "H",
    2: "He",
    3: "Li",
    4: "Be",
    5: "B",
    6: "C",
    7: "N",
    8: "O",
    9: "F",
    10: "Ne",
    11: "Na",
    12: "Mg",
    13: "Al",
    14: "Si",
    15: "P",
    16: "S",
    17: "Cl",
    18: "Ar",
    19: "K",
    20: "Ca",
    21: "Sc",
    22: "Ti",
    23: "V",
    24: "Cr",
    25: "Mn",
    26: "Fe",
    27: "Co",
    28: "Ni",
    29: "Cu",
    30: "Zn",
    31: "Ga",
    32: "Ge",
    33: "As",
    34: "Se",
    35: "Br",
    36: "Kr",
    37: "Rb",
    38: "Sr",
    39: "Y",
    40: "Zr",
    41: "Nb",
    42: "Mo",
    43: "Tc",
    44: "Ru",
    45: "Rh",
    46: "Pd",
    47: "Ag",
    48: "Cd",
    49: "In",
    50: "Sn",
    51: "Sb",
    52: "Te",
    53: "I",
    54: "Xe",
    55: "Cs",
    56: "Ba",
    57: "La",
    58: "Ce",
    59: "Pr",
    60: "Nd",
    61: "Pm",
    62: "Sm",
    63: "Eu",
    64: "Gd",
    65: "Tb",
    66: "Dy",
    67: "Ho",
    68: "Er",
    69: "Tm",
    70: "Yb",
    71: "Lu",
    72: "Hf",
    73: "Ta",
    74: "W",
    75: "Re",
    76: "Os",
    77: "Ir",
    78: "Pt",
    79: "Au",
    80: "Hg",
    81: "Tl",
    82: "Pb",
    83: "Bi",
    84: "Po",
    85: "At",
    86: "Rn",
    87: "Fr",
    88: "Ra",
    89: "Ac",
    90: "Th",
    91: "Pa",
    92: "U",
    93: "Np",
    94: "Pu",
    95: "Am",
    96: "Cm",
    97: "Bk",
    98: "Cf",
    99: "Es",
    100: "Fm",
    101: "Md",
    102: "No",
    103: "Lr",
    104: "Rf",
    105: "Db",
    106: "Sg",
    107: "Bh",
    108: "Hs",
    109: "Mt",
    110: "Ds",
    111: "Rg",
    112: "Cn",
    113: "Nh",
    114: "Fl",
    115: "Mc",
    116: "Lv",
    117: "Ts",
    118: "Og",
}
PSE_NUMBERS: dict[str, int] = {k.lower(): v for v, k in PSE.items()}
PSE_SYMBOLS: dict[int, str] = {v: k.lower() for v, k in PSE.items()}


def read_xyz_from_file(filename: str | Path) -> tuple[np.ndarray, np.ndarray]:
    """
    Read the XYZ coordinates of the molecule from a file.

    The layout of the file is as follows:
    ```
    num_atoms
    'Generated by mindlessgen-v{__version__}'
    <symbol 1> <x1> <y1> <z1>
    <symbol 2> <x2> <y2> <z2>
    ...
    ```

    :param filename: The name of the file to read from.
    """
    with open(filename, encoding="utf8") as f:
        lines = f.readlines()
        # read the number of atoms
        num_atoms = int(lines[0])
        ati = np.zeros(num_atoms, dtype=int)
        # read the atomic coordinates
        xyz = np.zeros((num_atoms, 3))
        for i in range(num_atoms):
            line = lines[i + 2].split()
            ati[i] = PSE_NUMBERS[line[0].lower()]
            xyz[i, 0] = float(line[1])
            xyz[i, 1] = float(line[2])
            xyz[i, 2] = float(line[3])

    return xyz, ati


def get_xyz_str(xyz: np.ndarray, ati: np.ndarray) -> str:
    """
    Return the content of an xyz file as a string.
    """
    xyz_str = f"{len(xyz)}\n"
    commentline = "Generated by ctcharge_nh4f-v0.1.0\n"
    xyz_str += commentline
    for i in range(len(xyz)):
        xyz_str += (
            f"{PSE[ati[i]]:<5} "
            + f"{xyz[i, 0]:>12.7f} "
            + f"{xyz[i, 1]:>12.7f} "
            + f"{xyz[i, 2]:>12.7f}\n"
        )
    return xyz_str


def write_xyz_to_file(filename: str | Path, xyz: np.ndarray, ati: np.ndarray) -> None:
    """
    Write the XYZ coordinates of the molecule to a file.

    The layout of the file is as follows:
    ```
    num_atoms

    <symbol 1> <x1> <y1> <z1>
    <symbol 2> <x2> <y2> <z2>
    ...
    ```

    :param filename: The name of the file to write to.
    """

    if filename:
        if not isinstance(filename, Path):
            filename = Path(filename).resolve()

    with open(filename, "w", encoding="utf8") as f:
        f.write(get_xyz_str(xyz, ati))


def main(
    args: argparse.Namespace,
    relevant_atoms: dict[str, list[int]] | None = None,
    add_part_data: bool = False,
) -> None:
    df = pd.read_csv(args.file, comment="#")

    # get all unique Method values
    methods = list(df["Method"].unique())

    # pivot the dataframe
    df = df.pivot(
        index=["CID", "Atom number", "Atom type"], columns="Method", values="Charge"
    ).reset_index()
    df.to_csv("charges_pivoted.csv", index=False)

    if args.gas:
        # exclude all methods that end with "_DIELECTRIC" or "_CPCM"
        methods = [
            method
            for method in methods
            if not method.endswith("_DIELECTRIC") and not method.endswith("_CPCM")
        ]
        print("Methods:", methods)
    if args.solvation:
        # include only methods that end with "_DIELECTRIC" or "_CPCM"
        methods = [
            method
            for method in methods
            if method.endswith("_DIELECTRIC") or method.endswith("_CPCM")
        ]
        print("Methods:", methods)

    # keep only the data point with "Atom type" == 9
    if not relevant_atoms:
        df = df[df["Atom type"] == 9]
    else:
        # keep only the relevant atoms
        cumulative_df = df.copy(deep=True)
        cumulative_df = cumulative_df[
            cumulative_df["Atom number"].isin(
                relevant_atoms[cumulative_df["CID"].iloc[0]]
            )
        ]
        # for debugging and validation: calculate the sum of charges for each CID and method
        if VERBOSITY > 0:
            for cid in cumulative_df["CID"].unique():
                print(f"CID: {cid}")
                for method in methods:
                    print(f"Method: {method}")
                    print(cumulative_df[(cumulative_df["CID"] == cid)][method].sum())
                print(f"data frame: {cumulative_df[(cumulative_df['CID'] == cid)]}")
        for method in methods:
            # calculate sum of values (atomic charges) for each CID and discard all other entries
            cumulative_df[method] = cumulative_df.groupby("CID")[method].transform(
                "sum"
            )
            # only keep the first row per CID
        cumulative_df = cumulative_df.drop_duplicates(subset="CID", keep="first")

        # print the pivoted dataframe to a file for debugging
        cumulative_df.to_csv("charges_pivoted_filtered.csv", index=False)

        # rename all methods to "<method>_partitioned"
        if add_part_data:
            for method in methods:
                cumulative_df.rename(
                    columns={method: f"{method}_partitioned"}, inplace=True
                )
            df = df[df["Atom type"] == 9]
            df = df.merge(cumulative_df, on=["CID", "Atom type", "Atom number"])
        else:
            df = cumulative_df

    if VERBOSITY > 0:
        print(df)
        if VERBOSITY > 1:
            df.to_csv("tmp.csv", index=False)
    # plot the charges
    plot_charges(df, methods, add_part_data)


def plot_charges(
    data: pd.DataFrame, methods: list[str], add_part_data: bool = False
) -> None:
    """
    Actual plotting using seaborn.
    """
    # fig, ax = plt.subplots(figsize=(8.5 * CM_TO_INCH, 6 * CM_TO_INCH))
    plt.figure(figsize=(8.5 * CM_TO_INCH, 5 * CM_TO_INCH))
    sns.set(style="darkgrid")

    # define Roboto Condensed as the default font
    plt.rcParams["font.family"] = "sans-serif"
    plt.rcParams["font.sans-serif"] = "Roboto Condensed"
    plt.rcParams["font.weight"] = "regular"

    for method in methods:
        if method in ["EEQ", "EEQ_DIELECTRIC"]:
            color = "#fcba00"
            marker = "p"
            label = method
            if "_DIELECTRIC" in method:
                label = r"EEQ$_\mathrm{dielec}$"
        elif method in ["EEQ_BC", "EEQ_BC_DIELECTRIC"]:
            color = "#D773F0"
            marker = "*"
            label = r"EEQ$_\mathrm{BC}$"
            if "_DIELECTRIC" in method:
                label = r"EEQ$_\mathrm{BC,dielec}$"
        elif method == "CEH-v2":
            color = "#07529a"
            marker = "o"
            label = "CEH"
        elif method in ["GFN1-xTB", "GFN1-xTB_CPCM"]:
            color = "#7AC284"
            marker = "s"
            label = method
            if "_CPCM" in method:
                label = r"GFN1-xTB$_\mathrm{CPCM}$"
        elif method in ["GFN2-xTB", "GFN2-xTB_CPCM"]:
            color = "#C73C5F"
            marker = "^"
            label = method
            if "_CPCM" in method:
                label = r"GFN2-xTB$_\mathrm{CPCM}$"
        elif method in ["wB97M-V", "wB97M-V_CPCM"]:
            color = "#909085"
            marker = "<"
            label = "ωB97M-V"
            if "_CPCM" in method:
                label = r"ωB97M-V$_\mathrm{CPCM}$"
        else:
            raise ValueError(f"Unknown method: {method}")

        p = sns.lineplot(
            data=data,
            x="CID",
            y=method,
            marker=marker,
            label=label,
            color=color,
            markeredgecolor="black",
            markeredgewidth=0.25,
            markersize=3,
            linewidth=1,
            linestyle="-",
        )
        if add_part_data and method in ["EEQ", "EEQ_BC", "wB97M-V", "CEH-v2"]:
            sns.lineplot(
                data=data,
                x="CID",
                y=f"{method}_partitioned",
                marker=marker,
                label=None,
                color=color,
                markeredgecolor="black",
                markeredgewidth=0.25,
                markersize=2,
                linewidth=0.75,
                linestyle="--",
            )

    # set y axis limits from 0.05 to -1.05
    plt.ylim(-1.05, 0.05)
    # include legend and put it above the plot
    plt.legend(fontsize=8, loc="upper center", bbox_to_anchor=(0.5, 1.3), ncol=3)
    # set y axis label
    plt.ylabel("atomic charge ($q$) on F / $e^{-}$", fontsize=8)
    # set x axis label
    plt.xlabel(r"F–H$_\mathrm{NH4}$ distance / Å", fontsize=8)
    # set xticks font size
    plt.xticks(fontsize=8)
    # set yticks font size, with ticks at -1.0, -0.75, -0.5, -0.25, 0.0
    plt.yticks(fontsize=8, ticks=[-1.0, -0.75, -0.5, -0.25, 0.0])
    # Generate output file name from the method names
    filename = "plot_nh4f.svg"
    # Saving the plot
    plt.savefig(filename, dpi=600, bbox_inches="tight")


def partition_atoms(compounds_file: str) -> dict[str, list[int]]:
    """
    Partition the atoms in the molecule.

    1. There are two fragments in the molecule NH4F: NH4 and F.
    2. They are dissociated along the x axis.
    3. Define the edge atoms of each fragment:
       a) The edge atom of NH4 is the last H (atom number 6)
       b) The edge atom of F is the first F (atom number 2)
    5. Each atom is assigned to the fragment it is closer to (in x direction).
    6. Return the list of atoms that are closer to the F fragment.

    Example of the compounds file:
    ```
    Name	Structure Path	Number of Atoms	Total Charge
    1.0	./1.0/struc.xyz	306	0.0
    5.0	./5.0/struc.xyz	306	0.0
    1.6	./1.6/struc.xyz	306	0.0
    1.8	./1.8/struc.xyz	306	0.0
    3.0	./3.0/struc.xyz	306	0.0
    1.4	./1.4/struc.xyz	306	0.0
    1.2	./1.2/struc.xyz	306	0.0
    3.6	./3.6/struc.xyz	306	0.0
    8.4	./8.4/struc.xyz	306	0.0
    2.4	./2.4/struc.xyz	306	0.0
    6.4	./6.4/struc.xyz	306	0.0
    ```

    Args:
        compounds_file (str): File with the compounds.

    Returns:
        dict[str, list[int]]: A dictionary with the CID as key and the atom numbers of the F fragment as value.
    """

    # read the compounds file
    df = pd.read_csv(compounds_file, sep="\t")

    atom_partitining: dict[str, list[int]] = {}
    # for each compound, read the structure file and assign the atoms to the fragments
    for _, row in df.iterrows():
        # read the structure file
        filename = Path(row["Structure Path"]).resolve()
        cid = row["Name"]
        # read the xyz file
        xyz, ati = read_xyz_from_file(filename)

        # return the atom numbers of the edge atoms
        NH4_EDGE = 6
        F_EDGE = 2

        # 1. create a numpy array with shape(num_atoms, 3)
        #    to store the atom number, the distance to NH4 and the distance to F
        distances = np.zeros((xyz.shape[0], 2))
        # 2. calculate the distances
        for i, atom in enumerate(xyz):
            distances[i, 0] = np.abs(atom[0] - xyz[NH4_EDGE - 1][0])
            distances[i, 1] = np.abs(atom[0] - xyz[F_EDGE - 1][0])

        # 3. assign the atoms to the fragments
        #    by comparing the distances to NH4 and F
        nh4_atoms_raw: list[int] = []
        f_atoms_raw: list[int] = []
        for i, atom in enumerate(distances):
            if atom[0] < atom[1]:
                nh4_atoms_raw.append(i + 1)
            else:
                f_atoms_raw.append(i + 1)

        # For each f atom: Check if it is closer than 1.5 A (Euclidean distance)
        # to an atom that is not part of the F fragment.
        nh4_atoms: list[int] = []
        f_atoms: list[int] = []
        converged = False
        cycles = 0
        while not converged:
            cycles += 1
            print(f"Cycle {cycles} on CID {cid}...")
            if cycles > 10:
                print("Warning: Convergence not reached after 10 cycles.")
                break
            nh4_atoms = nh4_atoms_raw.copy()
            f_atoms = f_atoms_raw.copy()
            for f_atom in f_atoms_raw:
                f_atom_xyz = xyz[f_atom - 1]
                for nh4_atom in nh4_atoms_raw:
                    nh4_atom_xyz = xyz[nh4_atom - 1]
                    if np.linalg.norm(f_atom_xyz - nh4_atom_xyz) < 1.5:
                        nh4_atoms.append(f_atom)
                        f_atoms.remove(f_atom)

            # check if the list of f atoms has changed
            if len(f_atoms_raw) == len(f_atoms):
                converged = True
            else:
                nh4_atoms_raw = nh4_atoms
                f_atoms_raw = f_atoms

        f_atoms_fixed = [2]
        nh4_atoms_fixed = [1, 3, 4, 5, 6]
        for atom in f_atoms_fixed:
            if atom not in f_atoms:
                f_atoms.append(atom)
            if atom in nh4_atoms:
                nh4_atoms.remove(atom)
        for atom in nh4_atoms_fixed:
            if atom not in nh4_atoms:
                nh4_atoms.append(atom)
            if atom in f_atoms:
                f_atoms.remove(atom)
        f_atoms.sort()
        nh4_atoms.sort()

        # Generate a new XYZ file with the atoms assigned to the fragments
        f_xyz: np.ndarray = np.zeros((len(f_atoms), 3))
        f_ati: np.ndarray = np.zeros(len(f_atoms), dtype=int)
        for i, atom in enumerate(f_atoms):
            f_xyz[i] = xyz[atom - 1]
            f_ati[i] = ati[atom - 1]
        nh4_xyz: np.ndarray = np.zeros((len(nh4_atoms), 3))
        nh4_ati: np.ndarray = np.zeros(len(nh4_atoms), dtype=int)
        for i, atom in enumerate(nh4_atoms):
            nh4_xyz[i] = xyz[atom - 1]
            nh4_ati[i] = ati[atom - 1]

        # write the new XYZ file with CID as filename
        write_xyz_to_file(f"{cid}_f.xyz", f_xyz, f_ati)
        write_xyz_to_file(f"{cid}_nh4.xyz", nh4_xyz, nh4_ati)

        if VERBOSITY > 0:
            print(f"F fragment atom indices: {f_atoms}")
        if 2 not in f_atoms:
            raise ValueError("F atom not in F fragment.")
        atom_partitining[cid] = f_atoms

    return atom_partitining


def get_args():
    # Argument parser
    parser = argparse.ArgumentParser(
        description="Plot the partial charge of an atom in a two-atom-molecule depending on the distance between the atoms."
    )
    parser.add_argument(
        "--file",
        "-f",
        type=str,
        required=True,
        help="Input file with the partial charges.",
    )
    parser.add_argument(
        "--gas",
        "-g",
        action="store_true",
        default=False,
        help="Plot the partial charges of the gas phase.",
    )
    parser.add_argument(
        "--solvation",
        "-s",
        action="store_true",
        default=False,
        help="Plot the partial charges of the solvated phase.",
    )
    parser.add_argument(
        "--partition",
        "-p",
        type=str,
        default=None,
        help="Partition the atoms in the molecule. Give compounds file as argument. Example: 'compounds_rev.csv'",
    )
    parser.add_argument(
        "--add_part_data",
        "-a",
        action="store_true",
        default=False,
        help="Add the partitioned data to the plot.",
    )

    args = parser.parse_args()
    return args


if __name__ == "__main__":
    args = get_args()
    if args.partition:
        partitioning = partition_atoms(args.partition)
        main(args, partitioning, args.add_part_data)
        raise SystemExit(0)
    main(args)
